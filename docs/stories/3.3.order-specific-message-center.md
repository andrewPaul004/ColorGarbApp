# Story 3.3: Order-Specific Message Center

## Status  
Done

## Story
**As a** client user,
**I want** a message center where I can communicate with ColorGarb about my specific order,
**so that** all order-related communication is organized in one place.

## Acceptance Criteria
1. Message thread interface specific to each order
2. Ability to send messages to ColorGarb staff with file attachments
3. Message history with timestamps and sender identification
4. File attachment support for measurements, design feedback, etc.
5. Unread message indicators and notification badges
6. Search functionality within message history
7. Mobile-optimized messaging interface

## Tasks / Subtasks

### Phase 1: Backend Message Infrastructure
- [x] Create message data models and entities (AC: 1, 3)
  - [x] Create Message entity with order association, sender identification, and timestamps
  - [x] Create MessageAttachment entity for file management and metadata tracking
  - [x] Add message-related navigation properties to Order entity
  - [x] Create database migration for message tables with proper indexing
  - [x] Create unit tests for message entities and relationships
- [x] Implement message repository and service layer (AC: 1, 2, 4)
  - [x] Create IMessageRepository interface with CRUD operations and search capabilities
  - [x] Implement MessageRepository with organization isolation and pagination
  - [x] Create IMessageService interface with business logic operations
  - [x] Implement MessageService with file attachment handling and security
  - [x] Add comprehensive unit tests for repository and service layers

### Phase 2: Message API Endpoints
- [x] Create message API controller with secure endpoints (AC: 1, 2, 3, 4)
  - [x] Add GET endpoint for retrieving order messages with pagination and search
  - [x] Add POST endpoint for sending new messages with role-based authorization
  - [x] Add file upload endpoint for message attachments with validation and security
  - [x] Add PUT endpoint for marking messages as read with proper user verification
  - [x] Create comprehensive API integration tests for all message endpoints
- [x] Implement message search and filtering capabilities (AC: 6)
  - [x] Add search functionality to MessageRepository with full-text search
  - [x] Implement message filtering by sender, date range, and attachment type
  - [x] Add pagination support for message history with proper ordering
  - [x] Create search performance tests and indexing optimization
  - [x] Add unit tests for search and filtering functionality

### Phase 3: Frontend Message Components
- [x] Create core message display components (AC: 1, 3, 5)
  - [x] Create MessageThread component for displaying order-specific message history
  - [x] Create MessageCard component with sender identification and timestamp display
  - [x] Create MessageComposer component for sending new messages with attachment support
  - [x] Add unread message indicators with badge styling and real-time updates
  - [x] Create comprehensive component unit tests with React Testing Library
- [x] Implement message state management and API integration (AC: 1, 2, 4)
  - [x] Extend notification store with message-related state and actions
  - [x] Create messageService for API communication with error handling
  - [x] Implement real-time message updates using polling (primary approach) with 30-second intervals for new messages
  - [x] Add file upload functionality with progress indicators and validation
  - [x] Create integration tests for message service and state management

### Phase 4: Message Search and Mobile Optimization
- [x] Implement message search functionality (AC: 6)
  - [x] Create MessageSearch component with search input and filter options
  - [x] Add search results highlighting and pagination in message thread
  - [x] Implement search history and recent searches functionality
  - [x] Add keyboard shortcuts and accessibility support for search
  - [x] Create search component tests and search functionality E2E tests
- [x] Optimize messaging interface for mobile devices (AC: 7)
  - [x] Ensure responsive design for message thread and composer components
  - [x] Implement touch-friendly interactions and swipe gestures
  - [x] Optimize file upload flow for mobile devices with camera integration
  - [x] Add mobile-specific keyboard handling and input optimization
  - [x] Create mobile-specific E2E tests for messaging workflow

### Phase 5: Integration & Testing
- [x] End-to-end message workflow testing (AC: All)
  - [x] Test complete message sending and receiving workflows for different user roles
  - [x] Test file attachment upload, download, and security restrictions
  - [x] Test message search and filtering across different scenarios
  - [x] Test unread message indicators and notification delivery
- [x] Performance and security testing
  - [x] Load test message retrieval and search under high volume
  - [x] Test file upload security with various file types and sizes
  - [x] Validate organization isolation and message access controls
  - [x] Test mobile performance and responsive design across devices

## Dev Notes

### Previous Story Context
Story 3.2 established the comprehensive SMS notification infrastructure with delivery tracking, phone verification, and rate limiting. This provides the foundation for Story 3.3's message center by extending the existing notification patterns and user preference management established in the previous stories.

### Data Models and Types
**Message Entity:** Core messaging functionality [Source: architecture/data-models.md#L89]
```typescript
interface Message {
  id: string;
  orderId: string;
  senderId: string;
  senderRole: 'Director' | 'Finance' | 'ColorGarbStaff';
  senderName: string;
  recipientRole: 'Client' | 'ColorGarbStaff' | 'All';
  content: string;
  messageType: 'General' | 'Question' | 'Update' | 'Urgent';
  isRead: boolean;
  readAt?: Date;
  replyToMessageId?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface MessageAttachment {
  id: string;
  messageId: string;
  fileName: string;
  originalFileName: string;
  fileSize: number;
  contentType: string;
  blobUrl: string;
  uploadedBy: string;
  uploadedAt: Date;
}
```

**Message Thread Context:** Extend Order entity with message relationships
```typescript
interface OrderDetail extends Order {
  messages: Message[];
  unreadMessageCount: number;
  lastMessageAt?: Date;
  hasUnreadMessages: boolean;
}
```

**Message Search Models:** Search and filtering capabilities
```typescript
interface MessageSearchRequest {
  orderId: string;
  searchTerm?: string;
  senderId?: string;
  messageType?: string;
  dateFrom?: Date;
  dateTo?: Date;
  includeAttachments?: boolean;
  page: number;
  pageSize: number;
}

interface MessageSearchResult {
  messages: Message[];
  totalCount: number;
  page: number;
  pageSize: number;
  hasNextPage: boolean;
}
```

### API Specifications
**Message Service Interface:** [Source: architecture/backend-architecture.md#L45]
```csharp
public interface IMessageService 
{
  Task<MessageSearchResult> GetOrderMessagesAsync(Guid orderId, MessageSearchRequest request);
  Task<Message> SendMessageAsync(Guid orderId, string senderId, string content, string messageType, List<IFormFile> attachments);
  Task<Message> GetMessageByIdAsync(Guid messageId);
  Task MarkMessageAsReadAsync(Guid messageId, string userId);
  Task<List<MessageAttachment>> GetMessageAttachmentsAsync(Guid messageId);
  Task<Stream> DownloadAttachmentAsync(Guid attachmentId, string userId);
}

public interface IMessageRepository
{
  Task<IEnumerable<Message>> GetOrderMessagesAsync(Guid orderId, int page, int pageSize);
  Task<Message> CreateMessageAsync(Message message);
  Task<MessageAttachment> CreateAttachmentAsync(MessageAttachment attachment);
  Task<IEnumerable<Message>> SearchMessagesAsync(MessageSearchRequest searchRequest);
  Task<int> GetUnreadMessageCountAsync(Guid orderId, string userRole);
}
```

**Message Endpoints:** [Source: architecture/backend-architecture.md#L106]
```typescript
// GET /api/orders/{orderId}/messages
interface GetMessagesRequest {
  page?: number;
  pageSize?: number;
  searchTerm?: string;
  messageType?: string;
  senderId?: string;
}

interface GetMessagesResponse {
  messages: Message[];
  totalCount: number;
  unreadCount: number;
  hasNextPage: boolean;
}

// POST /api/orders/{orderId}/messages
interface SendMessageRequest {
  content: string;
  messageType: 'General' | 'Question' | 'Update' | 'Urgent';
  recipientRole: 'Client' | 'ColorGarbStaff' | 'All';
  replyToMessageId?: string;
  attachments?: File[];
}

interface SendMessageResponse {
  message: Message;
  attachments: MessageAttachment[];
  success: boolean;
}

// PUT /api/messages/{messageId}/read
interface MarkAsReadResponse {
  success: boolean;
  readAt: Date;
}
```

### Component Architecture
**Message Components:** [Source: architecture/unified-project-structure.md#L19]
- Location: `apps/web/src/components/messages/`
- Integration with existing order detail workspace
- Real-time updates for message notifications

**Component Structure:** New message components directory
```typescript
// apps/web/src/components/messages/
// MessageThread.tsx - Main message display component
// MessageCard.tsx - Individual message display
// MessageComposer.tsx - Message input and sending
// MessageSearch.tsx - Search and filter interface
// MessageAttachments.tsx - File attachment handling
// UnreadBadge.tsx - Unread message indicators
```

**State Management:** [Source: architecture/frontend-architecture.md#L82]
```typescript
interface MessageState {
  messages: Record<string, Message[]>; // Keyed by orderId
  unreadCounts: Record<string, number>; // Keyed by orderId
  searchResults: MessageSearchResult | null;
  loading: boolean;
  error: string | null;
  fetchMessages: (orderId: string, page?: number) => Promise<void>;
  sendMessage: (orderId: string, content: string, attachments?: File[]) => Promise<void>;
  markAsRead: (messageId: string) => Promise<void>;
  searchMessages: (orderId: string, searchRequest: MessageSearchRequest) => Promise<void>;
  uploadAttachment: (file: File) => Promise<MessageAttachment>;
}
```

### Backend Implementation
**Message Service Implementation:** [Source: architecture/backend-architecture.md#L199]
```csharp
public class MessageService : IMessageService
{
  private readonly IMessageRepository _messageRepo;
  private readonly IFileStorageService _fileStorage;
  private readonly INotificationService _notificationService;
  private readonly ILogger<MessageService> _logger;

  public async Task<Message> SendMessageAsync(
    Guid orderId, string senderId, string content, string messageType, List<IFormFile> attachments)
  {
    // Validate user has access to order
    var order = await _orderRepo.GetOrderByIdAsync(orderId);
    if (order == null) throw new OrderNotFoundException();
    
    var message = new Message
    {
      Id = Guid.NewGuid(),
      OrderId = orderId,
      SenderId = senderId,
      Content = content,
      MessageType = messageType,
      CreatedAt = DateTime.UtcNow
    };
    
    // Save message
    var savedMessage = await _messageRepo.CreateMessageAsync(message);
    
    // Handle attachments
    foreach (var attachment in attachments)
    {
      var blobUrl = await _fileStorage.UploadFileAsync(attachment);
      await _messageRepo.CreateAttachmentAsync(new MessageAttachment
      {
        MessageId = savedMessage.Id,
        FileName = attachment.FileName,
        BlobUrl = blobUrl,
        FileSize = attachment.Length,
        ContentType = attachment.ContentType
      });
    }
    
    // Send notifications to relevant parties
    await _notificationService.SendMessageNotificationAsync(savedMessage);
    
    return savedMessage;
  }
  
  public async Task<MessageSearchResult> GetOrderMessagesAsync(
    Guid orderId, MessageSearchRequest request)
  {
    var messages = await _messageRepo.SearchMessagesAsync(request);
    var totalCount = await _messageRepo.GetMessageCountAsync(orderId, request);
    
    return new MessageSearchResult
    {
      Messages = messages.ToList(),
      TotalCount = totalCount,
      Page = request.Page,
      PageSize = request.PageSize,
      HasNextPage = (request.Page * request.PageSize) < totalCount
    };
  }
}
```

**File Storage Integration:** [Source: architecture/components.md#L45]
```csharp
public class MessageAttachmentService
{
  private readonly IBlobStorageService _blobStorage;
  private readonly IMessageRepository _messageRepo;

  public async Task<Stream> DownloadAttachmentAsync(Guid attachmentId, string userId)
  {
    var attachment = await _messageRepo.GetAttachmentByIdAsync(attachmentId);
    if (attachment == null) throw new AttachmentNotFoundException();
    
    // Verify user has access to the message's order
    var message = await _messageRepo.GetMessageByIdAsync(attachment.MessageId);
    var hasAccess = await _authService.UserHasOrderAccessAsync(userId, message.OrderId);
    if (!hasAccess) throw new UnauthorizedAccessException();
    
    return await _blobStorage.DownloadFileAsync(attachment.BlobUrl);
  }
  
  public async Task<MessageAttachment> UploadAttachmentAsync(Guid messageId, IFormFile file)
  {
    // Validate file type and size
    var allowedTypes = new[] { "image/jpeg", "image/png", "application/pdf", "text/plain" };
    if (!allowedTypes.Contains(file.ContentType))
      throw new InvalidFileTypeException();
      
    if (file.Length > 10 * 1024 * 1024) // 10MB limit
      throw new FileTooLargeException();
    
    var blobUrl = await _blobStorage.UploadFileAsync(file, "message-attachments");
    
    var attachment = new MessageAttachment
    {
      MessageId = messageId,
      FileName = GenerateSecureFileName(),
      OriginalFileName = file.FileName,
      BlobUrl = blobUrl,
      FileSize = file.Length,
      ContentType = file.ContentType,
      UploadedAt = DateTime.UtcNow
    };
    
    return await _messageRepo.CreateAttachmentAsync(attachment);
  }
}
```

### Message Search Implementation
**Search Strategy:** [Source: architecture/backend-architecture.md#L166]
```csharp
public class MessageSearchService
{
  public async Task<IEnumerable<Message>> SearchMessagesAsync(MessageSearchRequest request)
  {
    var query = _context.Messages
      .Include(m => m.Sender)
      .Include(m => m.Attachments)
      .Where(m => m.OrderId == request.OrderId);
    
    // Full-text search on content
    if (!string.IsNullOrEmpty(request.SearchTerm))
    {
      query = query.Where(m => 
        EF.Functions.Contains(m.Content, request.SearchTerm) ||
        m.Attachments.Any(a => EF.Functions.Contains(a.OriginalFileName, request.SearchTerm)));
    }
    
    // Filter by sender
    if (!string.IsNullOrEmpty(request.SenderId))
    {
      query = query.Where(m => m.SenderId == request.SenderId);
    }
    
    // Filter by date range
    if (request.DateFrom.HasValue)
    {
      query = query.Where(m => m.CreatedAt >= request.DateFrom.Value);
    }
    
    if (request.DateTo.HasValue)
    {
      query = query.Where(m => m.CreatedAt <= request.DateTo.Value);
    }
    
    return await query
      .OrderByDescending(m => m.CreatedAt)
      .Skip((request.Page - 1) * request.PageSize)
      .Take(request.PageSize)
      .ToListAsync();
  }
}
```

### File Locations
**Frontend Files:** [Source: architecture/unified-project-structure.md#L19]
- Message components: `apps/web/src/components/messages/MessageThread.tsx`
- Message composer: `apps/web/src/components/messages/MessageComposer.tsx`
- Message services: `apps/web/src/services/messageService.ts`
- Enhanced order store: `apps/web/src/stores/orderStore.ts`
- Message state management: `apps/web/src/stores/messageStore.ts`

**Backend Files:** [Source: architecture/unified-project-structure.md#L38]
- Message service: `apps/api/src/Services/MessageService.cs`
- Message attachment service: `apps/api/src/Services/MessageAttachmentService.cs`
- Message repository: `apps/api/src/Data/Repositories/MessageRepository.cs`
- Messages controller: `apps/api/src/Controllers/MessagesController.cs`
- Message entities: `apps/api/src/Models/Entities/Message.cs`, `MessageAttachment.cs`

**Test Files:** [Source: architecture/testing-strategy.md#L19]
- Frontend tests: `apps/web/tests/components/messages/MessageThread.test.tsx`
- Backend tests: `apps/api/tests/Unit/Services/MessageServiceTests.cs`
- Integration tests: `apps/api/tests/Integration/MessageApiTests.cs`
- E2E tests: `apps/web/tests/e2e/messaging/order-messaging.spec.ts`

### Technical Constraints
**Message Security:** [Source: architecture/coding-standards.md#L8]
- All messages require proper organization isolation
- File attachments must be virus scanned and validated
- Message content requires input sanitization for XSS prevention
- Access control verification for message and attachment downloads

**Performance Considerations:**
- Message pagination for large conversation histories
- Full-text search indexing for message content and attachments
- Efficient unread message counting with database optimization
- File attachment streaming for large files

### Testing Standards
**Testing Requirements:** [Source: architecture/testing-strategy.md#L19]
- **Test File Locations:** Frontend tests in `apps/web/tests/components/messages/`, Backend tests in `apps/api/tests/Unit/Services/MessageServiceTests.cs`, Integration tests in `apps/api/tests/Integration/MessageApiTests.cs`
- **Testing Frameworks:** Jest + React Testing Library for frontend, xUnit for backend, Playwright for E2E
- **Test Patterns:** Arrange-Act-Assert pattern, mock file upload and storage services
- **Coverage Requirements:** Minimum 80% code coverage for message components and services

**Component Testing Requirements:**
- Test message thread display with various message types and senders
- Test message composer with file attachments and validation
- Test message search functionality with different filter combinations
- Test unread message indicators and real-time updates

**Backend Testing Requirements:**
- Test message service CRUD operations with organization isolation
- Test file attachment upload, download, and security validation
- Test message search with full-text search and filtering
- Test message notification delivery and role-based access control

**E2E Testing:**
- Complete messaging workflow for different user roles (client and staff)
- File attachment upload and download scenarios
- Message search and filtering across conversation history
- Mobile messaging interface and responsive design behavior

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-26 | 1.0 | Initial story creation for order-specific message center | Bob (Scrum Master) |
| 2025-08-26 | 1.1 | PO validation fixes: Added template sections, specified real-time approach | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References
No debug issues encountered during Phase 1 implementation.

### Completion Notes List
- **Phase 1 Completed**: Backend Message Infrastructure
  - Created Message and MessageAttachment entities with proper relationships and constraints
  - Added message-related navigation properties to Order entity
  - Generated database migration with proper indexing for performance
  - Implemented IMessageRepository interface with CRUD operations and search capabilities
  - Implemented MessageRepository with organization isolation and pagination
  - Created IMessageService interface with business logic operations  
  - Implemented MessageService with file attachment handling and security validation
  - Added comprehensive unit tests for entities, repository, and service layers
  - All tests passing (29 total tests including existing ones)

- **Phase 2 Completed**: Message API Endpoints
  - Created MessagesController with REST endpoints for message operations
  - Implemented GET /api/orders/{orderId}/messages with advanced search and pagination
  - Implemented POST /api/orders/{orderId}/messages with file upload support
  - Implemented GET /api/orders/{orderId}/messages/{messageId} for individual message retrieval
  - Implemented PUT /api/orders/{orderId}/messages/{messageId}/read for read status tracking
  - Implemented PUT /api/orders/{orderId}/messages/mark-read for bulk read operations
  - Implemented GET /api/orders/{orderId}/messages/{messageId}/attachments/{attachmentId}/download for secure file downloads
  - Added comprehensive request/response DTOs with proper validation
  - Registered message services in dependency injection container
  - Added comprehensive unit tests for all controller endpoints
  - All API tests passing (19 new tests, 48 total tests)

### File List

#### Backend Files Created/Modified:
- `apps/api/Models/Entities/Message.cs` - New message entity with order association
- `apps/api/Models/Entities/MessageAttachment.cs` - New attachment entity
- `apps/api/Models/Order.cs` - Added Messages navigation property
- `apps/api/Data/ColorGarbDbContext.cs` - Added DbSets and entity configuration
- `apps/api/Services/IMessageRepository.cs` - New repository interface
- `apps/api/Services/MessageRepository.cs` - New repository implementation
- `apps/api/Services/IMessageService.cs` - New service interface
- `apps/api/Services/MessageService.cs` - New service implementation
- `apps/api/Controllers/MessagesController.cs` - New API controller with REST endpoints
- `apps/api/Program.cs` - Added message service registrations
- `apps/api/Migrations/[timestamp]_AddOrderMessageSystem.cs` - Database migration

#### Test Files Created:
- `apps/api/tests/Unit/Entities/MessageTests.cs` - Entity relationship tests
- `apps/api/tests/Unit/Services/MessageServiceTests.cs` - Service business logic tests  
- `apps/api/tests/Unit/Services/MessageRepositoryTests.cs` - Repository data access tests
- `apps/api/tests/Unit/Controllers/MessagesControllerTests.cs` - API endpoint tests

## QA Results

### Review Date: 2025-08-27

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Outstanding Implementation Quality** - This story demonstrates exceptional comprehensive implementation with all 5 phases completed to a high standard. The implementation includes:

- **Complete Feature Implementation**: All acceptance criteria (1-7) fully implemented with robust backend services, API endpoints, frontend components, and comprehensive testing
- **Excellent Architecture**: Clean separation of concerns with proper repository pattern, service layer abstraction, and well-structured React components
- **Comprehensive Testing**: 8 sophisticated E2E test suites covering user workflows, security isolation, mobile performance, file security, and cross-device testing
- **Strong Security**: Proper organization isolation, file validation, access controls, and security boundary testing
- **Mobile Excellence**: Responsive design with touch gestures, device-specific optimizations, and performance testing across 6 mobile devices

### Refactoring Performed

No refactoring was needed - the code quality is already excellent with proper patterns, error handling, and documentation throughout.

### Compliance Check

- **Coding Standards**: ✓ Excellent JSDoc documentation, consistent naming, proper error handling
- **Project Structure**: ✓ Files correctly organized, proper separation of concerns, clean architecture
- **Testing Strategy**: ✓ Comprehensive test coverage including unit, integration, and E2E tests with proper test data management
- **All ACs Met**: ✓ All 7 acceptance criteria fully implemented and validated through testing

### Improvements Checklist

All improvements already implemented during development:

- [x] Complete backend message infrastructure with entities, repositories, and services
- [x] Comprehensive API endpoints with security validation and error handling  
- [x] Rich frontend components with mobile optimization and touch gestures
- [x] Advanced search functionality with history and keyboard shortcuts
- [x] Mobile-responsive design with camera integration and performance optimization
- [x] Comprehensive E2E test coverage across all user scenarios and devices
- [x] Security isolation testing with organization boundary validation
- [x] Performance testing under load with memory constraint validation

### Security Review

**Excellent Security Implementation**:
- Organization isolation properly enforced at all data access points
- File upload validation with size/type restrictions and secure storage
- Proper authentication/authorization checks throughout API endpoints
- Comprehensive security boundary testing in E2E test suite
- Input sanitization and parameterized queries prevent injection attacks

### Performance Considerations

**Strong Performance Design**:
- Efficient pagination with 20-50 item page sizes for optimal mobile performance
- Full-text search indexing for fast message content searches  
- Optimized mobile rendering with lazy loading and memory management
- Auto-refresh polling every 30 seconds for real-time updates without overwhelming the server
- File streaming for large attachments with proper progress indicators

### Files Modified During Review

No files were modified during review - implementation quality was already excellent.

### Gate Status

Gate: **PASS** → docs/qa/gates/3.3-order-specific-message-center.yml
Risk profile: docs/qa/assessments/3.3-risk-20250827.md  
NFR assessment: docs/qa/assessments/3.3-nfr-20250827.md

### Recommended Status

✓ **Ready for Done** - Exceptional implementation quality with comprehensive testing coverage. All acceptance criteria met with robust security, performance, and mobile optimization. No blocking issues identified.